"""
è‡ªåŠ¨æ ¡å‡†ä»»åŠ¡ç®¡ç†å™¨
è´Ÿè´£å¤„ç†ç£åŠ›é“¾æ¥çš„è‡ªåŠ¨æ ¡å‡†ä»»åŠ¡

Architecture: Uses new layered architecture
- src/core/container for service access
- src/application/services for business logic
"""
import logging
import os
import subprocess
import sys
from typing import Optional, List, Dict

# New architecture imports
from src.core.container import get_calibration_service, get_note_service

# Legacy imports (for functions not yet migrated to services)
from database import (
    add_calibration_task,
    get_pending_calibration_tasks,
    update_calibration_task,
    get_note_by_id,
    update_note_with_calibrated_dn,
    update_note_with_calibrated_dns,  # å¤šç£åŠ›é“¾æ¥æ›´æ–°
)
from bot.utils.magnet_utils import MagnetLinkParser

logger = logging.getLogger(__name__)


class CalibrationManager:
    """æ ¡å‡†ä»»åŠ¡ç®¡ç†å™¨

    Uses CalibrationService from new architecture for configuration management.
    """

    def __init__(self):
        self.config = None
        self._calibration_service = None
        self.reload_config()

    @property
    def calibration_service(self):
        """Lazy load calibration service"""
        if self._calibration_service is None:
            self._calibration_service = get_calibration_service()
        return self._calibration_service

    def reload_config(self):
        """é‡æ–°åŠ è½½é…ç½® - ä½¿ç”¨ CalibrationService"""
        try:
            config_obj = self.calibration_service.get_config()
            self.config = config_obj.to_dict()
            if self.config:
                logger.info(f"ğŸ“‹ æ ¡å‡†é…ç½®å·²åŠ è½½: enabled={self.config['enabled']}, filter_mode={self.config['filter_mode']}")
            else:
                logger.warning("âš ï¸ æ— æ³•åŠ è½½æ ¡å‡†é…ç½®")
        except Exception as e:
            logger.error(f"âŒ åŠ è½½æ ¡å‡†é…ç½®å¤±è´¥: {e}")
            self.config = None

    def is_enabled(self) -> bool:
        """æ£€æŸ¥è‡ªåŠ¨æ ¡å‡†æ˜¯å¦å¯ç”¨ - ä½¿ç”¨ CalibrationService"""
        return self.calibration_service.is_enabled()

    def should_calibrate_note(self, note: Dict) -> bool:
        """åˆ¤æ–­ç¬”è®°æ˜¯å¦éœ€è¦æ ¡å‡†

        Args:
            note: ç¬”è®°å­—å…¸

        Returns:
            æ˜¯å¦éœ€è¦æ ¡å‡†
        """
        if not self.is_enabled():
            return False

        magnet_link = note.get('magnet_link')
        message_text = note.get('message_text', '')

        # å¦‚æœæ—¢æ²¡æœ‰magnet_linkä¹Ÿæ²¡æœ‰æ–‡æœ¬ä¸­çš„ç£åŠ›é“¾æ¥ï¼Œä¸éœ€è¦æ ¡å‡†
        all_magnets = self.extract_all_magnets_from_text(message_text)
        if not magnet_link and not all_magnets:
            return False

        filter_mode = self.config.get('filter_mode', 'empty_only')

        # æ£€æŸ¥filenameå­—æ®µæ˜¯å¦ä¸ºç©ºï¼ˆçœŸæ­£æ ¡å‡†æˆåŠŸåæ‰ä¼šå¡«å……ï¼‰
        filename = note.get('filename')

        if filter_mode == 'empty_only':
            # ä»…æ ¡å‡†æœªæ ¡å‡†è¿‡çš„ç¬”è®°
            # è§„åˆ™ï¼šåªæœ‰æ²¡æœ‰dnå‚æ•°çš„ç£åŠ›é“¾æ¥æ‰éœ€è¦æ ¡å‡†

            # å¦‚æœmagnet_linkæœ‰dnå‚æ•°ï¼Œè¯´æ˜å·²ç»æœ‰æ–‡ä»¶åï¼Œä¸éœ€è¦æ ¡å‡†
            if magnet_link:
                from urllib.parse import parse_qs, urlparse, unquote
                try:
                    # è§£æmagneté“¾æ¥çš„dnå‚æ•°
                    parsed = urlparse(magnet_link)
                    params = parse_qs(parsed.query)
                    dn_values = params.get('dn', [])

                    if dn_values:
                        # æœ‰dnå‚æ•°ï¼Œä¸éœ€è¦æ ¡å‡†
                        logger.debug(f"ç¬”è®° {note.get('id')} çš„ç£åŠ›é“¾æ¥å·²æœ‰dnå‚æ•°ï¼Œè·³è¿‡æ ¡å‡†")
                        return False
                except Exception as e:
                    logger.debug(f"è§£ædnå‚æ•°å¤±è´¥: {e}")

            # æ²¡æœ‰dnå‚æ•°ï¼Œæ£€æŸ¥filename
            if not filename or filename.strip() == '':
                # filenameä¸ºç©ºï¼Œéœ€è¦æ ¡å‡†
                return True

            # filenameä¸ä¸ºç©ºï¼Œè¯´æ˜å·²ç»æ ¡å‡†è¿‡ï¼Œä¸éœ€è¦å†æ ¡å‡†
            return False

        elif filter_mode == 'all':
            # æ ¡å‡†æ‰€æœ‰ç¬”è®°
            return True

        return False

    def extract_magnet_hash(self, magnet_link: str) -> Optional[str]:
        """ä»ç£åŠ›é“¾æ¥æå–info hash

        Args:
            magnet_link: ç£åŠ›é“¾æ¥

        Returns:
            info hashï¼ˆå¤§å†™ï¼‰
        """
        return MagnetLinkParser.extract_info_hash(magnet_link)

    def extract_all_magnets_from_text(self, message_text: str) -> List[str]:
        """ä»ç¬”è®°æ–‡æœ¬ä¸­æå–æ‰€æœ‰ç£åŠ›é“¾æ¥

        Args:
            message_text: ç¬”è®°æ–‡æœ¬

        Returns:
            ç£åŠ›é“¾æ¥åˆ—è¡¨
        """
        return MagnetLinkParser.extract_all_magnets(message_text)

    def extract_all_dns_from_note(self, note: Dict) -> List[Dict]:
        """ä»ç¬”è®°ä¸­æå–æ‰€æœ‰ç£åŠ›é“¾æ¥çš„ä¿¡æ¯ï¼ˆä¸app.pyä¿æŒä¸€è‡´ï¼‰

        Args:
            note: ç¬”è®°å­—å…¸

        Returns:
            [{'magnet': ç£åŠ›é“¾æ¥, 'info_hash': info_hash}, ...]
        """
        message_text = note.get('message_text', '')
        filename = note.get('filename')

        # ä½¿ç”¨ç»Ÿä¸€çš„å·¥å…·å‡½æ•°
        all_info = MagnetLinkParser.extract_all_magnet_info(message_text, filename)

        # è½¬æ¢ä¸ºæ—§æ ¼å¼ï¼ˆå‘åå…¼å®¹ï¼‰
        return [{'magnet': info['magnet'], 'info_hash': info['info_hash']} for info in all_info]

    def add_note_to_calibration_queue(self, note_id: int, force: bool = False) -> bool:
        """å°†ç¬”è®°æ·»åŠ åˆ°æ ¡å‡†é˜Ÿåˆ—ï¼ˆä¸ºæ¯ä¸ªç£åŠ›é“¾æ¥åˆ›å»ºç‹¬ç«‹ä»»åŠ¡ï¼‰

        Args:
            note_id: ç¬”è®°ID
            force: æ˜¯å¦å¼ºåˆ¶æ·»åŠ ï¼ˆè·³è¿‡æ ¡å‡†æ£€æŸ¥ï¼‰

        Returns:
            æ˜¯å¦æˆåŠŸæ·»åŠ ï¼ˆè‡³å°‘æ·»åŠ ä¸€ä¸ªä»»åŠ¡ï¼‰
        """
        try:
            logger.info(f"ğŸ”„ å¼€å§‹å¤„ç†æ ¡å‡†ä»»åŠ¡: note_id={note_id}, force={force}")

            note = get_note_by_id(note_id)
            if not note:
                logger.warning(f"âš ï¸ ç¬”è®° {note_id} ä¸å­˜åœ¨")
                return False

            logger.info(f"âœ… ç¬”è®°å·²æ‰¾åˆ°: note_id={note_id}, magnet_link={'æœ‰' if note.get('magnet_link') else 'æ— '}")

            # å¦‚æœä¸æ˜¯å¼ºåˆ¶æ¨¡å¼ï¼Œæ£€æŸ¥æ˜¯å¦éœ€è¦æ ¡å‡†
            if not force and not self.should_calibrate_note(note):
                logger.info(f"â­ï¸ ç¬”è®° {note_id} ä¸éœ€è¦æ ¡å‡†ï¼ˆfilter_mode={self.config.get('filter_mode')}ï¼‰")
                return False

            if force:
                logger.info(f"âœ… å¼ºåˆ¶æ¨¡å¼ï¼šè·³è¿‡æ ¡å‡†æ£€æŸ¥ï¼Œç›´æ¥æ·»åŠ ç¬”è®° {note_id}")
            else:
                logger.info(f"âœ… ç¬”è®°éœ€è¦æ ¡å‡†: note_id={note_id}")

            # æå–æ‰€æœ‰ç£åŠ›é“¾æ¥ï¼ˆæ”¯æŒå¤šæ¡ï¼‰
            all_dns = self.extract_all_dns_from_note(note)
            if not all_dns:
                logger.warning(f"âš ï¸ æ— æ³•ä»ç¬”è®° {note_id} æå–ç£åŠ›é“¾æ¥")
                return False

            logger.info(f"âœ… å‘ç° {len(all_dns)} ä¸ªç£åŠ›é“¾æ¥ï¼Œä¸ºæ¯ä¸ªç£åŠ›é“¾æ¥åˆ›å»ºç‹¬ç«‹ä»»åŠ¡")

            # ä¸ºæ¯ä¸ªç£åŠ›é“¾æ¥åˆ›å»ºç‹¬ç«‹çš„æ ¡å‡†ä»»åŠ¡
            first_delay = self.config.get('first_delay', 600)
            added_count = 0

            for idx, dn_info in enumerate(all_dns, 1):
                magnet_hash = dn_info['info_hash']

                # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨è¯¥ç£åŠ›é“¾æ¥çš„ä»»åŠ¡
                task_id = add_calibration_task(note_id, magnet_hash, first_delay)

                if task_id:
                    logger.info(f"âœ… ç¬¬ {idx}/{len(all_dns)} ä¸ªç£åŠ›é“¾æ¥ä»»åŠ¡å·²æ·»åŠ : task_id={task_id}, hash={magnet_hash[:16]}...")
                    added_count += 1
                else:
                    logger.warning(f"âš ï¸ ç¬¬ {idx}/{len(all_dns)} ä¸ªç£åŠ›é“¾æ¥ä»»åŠ¡æ·»åŠ å¤±è´¥ï¼ˆå¯èƒ½å·²å­˜åœ¨ï¼‰: hash={magnet_hash[:16]}...")

            if added_count > 0:
                logger.info(f"ğŸ‰ æ ¡å‡†ä»»åŠ¡æ·»åŠ å®Œæˆ: note_id={note_id}, æˆåŠŸæ·»åŠ  {added_count}/{len(all_dns)} ä¸ªä»»åŠ¡")
                return True
            else:
                logger.warning(f"âš ï¸ æ²¡æœ‰æ·»åŠ ä»»ä½•æ–°ä»»åŠ¡: note_id={note_id}")
                return False

        except Exception as e:
            logger.error(f"âŒ æ·»åŠ æ ¡å‡†ä»»åŠ¡å¼‚å¸¸: note_id={note_id}, error={e}", exc_info=True)
            return False

    def calibrate_magnet(self, magnet_hash: str, timeout: int = 30, prefer_bot: bool = True) -> Optional[str]:
        """æ ¡å‡†å•ä¸ªç£åŠ›é“¾æ¥ï¼Œè·å–çœŸå®æ–‡ä»¶å

        Args:
            magnet_hash: ç£åŠ›é“¾æ¥çš„info hash
            timeout: è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            prefer_bot: æ˜¯å¦ä¼˜å…ˆä½¿ç”¨æœºå™¨äººæ–¹å¼ï¼ˆTrue=è‡ªåŠ¨æ ¡å‡†ä¼˜å…ˆæœºå™¨äººï¼ŒFalse=æ‰‹åŠ¨æ ¡å‡†ä¼˜å…ˆqBittorrentï¼‰

        Returns:
            æ–‡ä»¶åï¼Œå¤±è´¥è¿”å›None
        """
        try:
            # å®¹å™¨å†…å·¥ä½œç›®å½•æ˜¯/app,å®¿ä¸»æœºæ˜¯/root/Save-Restricted-Bot
            qbt_script_path = '/app/calibrate_qbt_helper.py' if os.path.exists('/app/calibrate_qbt_helper.py') else os.path.join(os.path.dirname(__file__), '../../calibrate_qbt_helper.py')
            bot_script_path = '/app/calibrate_bot_helper.py' if os.path.exists('/app/calibrate_bot_helper.py') else os.path.join(os.path.dirname(__file__), '../../calibrate_bot_helper.py')

            # æ ¹æ®prefer_botå‚æ•°å†³å®šä¼˜å…ˆçº§
            if prefer_bot:
                # è‡ªåŠ¨æ ¡å‡†ï¼šä¼˜å…ˆä½¿ç”¨Telegramæœºå™¨äºº
                logger.info(f"ğŸ”„ è‡ªåŠ¨æ ¡å‡†æ¨¡å¼ï¼šä¼˜å…ˆä½¿ç”¨Telegramæœºå™¨äºº")

                # ä¼˜å…ˆå°è¯•æœºå™¨äººæ–¹å¼
                if os.path.exists(bot_script_path):
                    logger.info(f"ğŸ”„ ä½¿ç”¨Telegramæœºå™¨äººæ ¡å‡†: {magnet_hash[:16]}...")
                    result = subprocess.run(
                        [sys.executable, bot_script_path, magnet_hash],
                        capture_output=True,
                        text=True,
                        timeout=timeout
                    )

                    if result.returncode == 0 and result.stdout.strip():
                        filename = result.stdout.strip()
                        logger.info(f"âœ… Telegramæœºå™¨äººæ ¡å‡†æˆåŠŸ: {filename[:50]}...")
                        return filename
                    else:
                        error_msg = result.stderr.strip() if result.stderr else "æœªçŸ¥é”™è¯¯"
                        logger.warning(f"âš ï¸ Telegramæœºå™¨äººæ ¡å‡†å¤±è´¥: {error_msg[:100]}")
                        logger.info(f"ğŸ”„ å›é€€åˆ°qBittorrent APIæ–¹å¼...")

                # å›é€€åˆ°qBittorrent APIæ–¹å¼
                if os.path.exists(qbt_script_path):
                    logger.info(f"ğŸ”„ å°è¯•ä½¿ç”¨qBittorrent APIæ ¡å‡†: {magnet_hash[:16]}...")
                    result = subprocess.run(
                        [sys.executable, qbt_script_path, magnet_hash],
                        capture_output=True,
                        text=True,
                        timeout=timeout
                    )

                    if result.returncode == 0 and result.stdout.strip():
                        filename = result.stdout.strip()
                        logger.info(f"âœ… qBittorrent APIæ ¡å‡†æˆåŠŸ: {filename[:50]}...")
                        return filename
                    else:
                        error_msg = result.stderr.strip() if result.stderr else "æœªçŸ¥é”™è¯¯"
                        logger.warning(f"âš ï¸ qBittorrent APIæ ¡å‡†å¤±è´¥: {error_msg[:100]}")
            else:
                # æ‰‹åŠ¨æ ¡å‡†ï¼šä¼˜å…ˆä½¿ç”¨qBittorrent API
                logger.info(f"ğŸ”„ æ‰‹åŠ¨æ ¡å‡†æ¨¡å¼ï¼šä¼˜å…ˆä½¿ç”¨qBittorrent API")

                # ä¼˜å…ˆå°è¯•qBittorrent APIæ–¹å¼
                if os.path.exists(qbt_script_path):
                    logger.info(f"ğŸ”„ å°è¯•ä½¿ç”¨qBittorrent APIæ ¡å‡†: {magnet_hash[:16]}...")
                    result = subprocess.run(
                        [sys.executable, qbt_script_path, magnet_hash],
                        capture_output=True,
                        text=True,
                        timeout=timeout
                    )

                    if result.returncode == 0 and result.stdout.strip():
                        filename = result.stdout.strip()
                        logger.info(f"âœ… qBittorrent APIæ ¡å‡†æˆåŠŸ: {filename[:50]}...")
                        return filename
                    else:
                        error_msg = result.stderr.strip() if result.stderr else "æœªçŸ¥é”™è¯¯"
                        logger.warning(f"âš ï¸ qBittorrent APIæ ¡å‡†å¤±è´¥: {error_msg[:100]}")
                        logger.info(f"ğŸ”„ å›é€€åˆ°Telegramæœºå™¨äººæ–¹å¼...")

                # å›é€€åˆ°æœºå™¨äººæ–¹å¼
                if os.path.exists(bot_script_path):
                    logger.info(f"ğŸ”„ ä½¿ç”¨Telegramæœºå™¨äººæ ¡å‡†: {magnet_hash[:16]}...")
                    result = subprocess.run(
                        [sys.executable, bot_script_path, magnet_hash],
                        capture_output=True,
                        text=True,
                        timeout=timeout
                    )

                    if result.returncode == 0 and result.stdout.strip():
                        filename = result.stdout.strip()
                        logger.info(f"âœ… Telegramæœºå™¨äººæ ¡å‡†æˆåŠŸ: {filename[:50]}...")
                        return filename
                    else:
                        error_msg = result.stderr.strip() if result.stderr else "æœªçŸ¥é”™è¯¯"
                        logger.warning(f"âš ï¸ Telegramæœºå™¨äººæ ¡å‡†å¤±è´¥: {error_msg[:100]}")

            logger.error(f"âŒ æ‰€æœ‰æ ¡å‡†æ–¹å¼éƒ½å¤±è´¥äº†")
            return None

        except subprocess.TimeoutExpired:
            logger.warning(f"âš ï¸ æ ¡å‡†è¶…æ—¶ï¼ˆ{timeout}ç§’ï¼‰")
            return None
        except Exception as e:
            logger.error(f"æ ¡å‡†è¿‡ç¨‹å‡ºé”™: {e}", exc_info=True)
            return None

    def process_calibration_task(self, task: Dict) -> bool:
        """å¤„ç†å•ä¸ªæ ¡å‡†ä»»åŠ¡ï¼ˆåªå¤„ç†ä»»åŠ¡æŒ‡å®šçš„ç£åŠ›é“¾æ¥ï¼‰

        Args:
            task: ä»»åŠ¡å­—å…¸

        Returns:
            æ˜¯å¦æˆåŠŸ
        """
        task_id = task['id']
        note_id = task['note_id']
        magnet_hash = task['magnet_hash']
        retry_count = task['retry_count']

        logger.info(f"ğŸ”§ å¼€å§‹å¤„ç†æ ¡å‡†ä»»åŠ¡: task_id={task_id}, note_id={note_id}, hash={magnet_hash[:16]}..., retry={retry_count}")

        try:
            # è·å–ç¬”è®°ä¿¡æ¯
            note = get_note_by_id(note_id)
            if not note:
                logger.warning(f"ç¬”è®° {note_id} ä¸å­˜åœ¨ï¼Œåˆ é™¤ä»»åŠ¡")
                update_calibration_task(task_id, 'failed', 'ç¬”è®°ä¸å­˜åœ¨')
                return False

            # æå–æ‰€æœ‰ç£åŠ›é“¾æ¥ï¼Œæ‰¾åˆ°å½“å‰ä»»åŠ¡å¯¹åº”çš„ç£åŠ›é“¾æ¥
            all_dns = self.extract_all_dns_from_note(note)

            if not all_dns:
                logger.warning(f"âš ï¸ ç¬”è®° {note_id} æ²¡æœ‰æ‰¾åˆ°ç£åŠ›é“¾æ¥")
                update_calibration_task(task_id, 'failed', 'æ²¡æœ‰æ‰¾åˆ°ç£åŠ›é“¾æ¥')
                return False

            # æ‰¾åˆ°å½“å‰ä»»åŠ¡å¯¹åº”çš„ç£åŠ›é“¾æ¥
            target_magnet = None
            for dn_info in all_dns:
                if dn_info['info_hash'] == magnet_hash:
                    target_magnet = dn_info
                    break

            if not target_magnet:
                logger.warning(f"âš ï¸ ç¬”è®° {note_id} ä¸­æœªæ‰¾åˆ° hash={magnet_hash[:16]}... çš„ç£åŠ›é“¾æ¥")
                update_calibration_task(task_id, 'failed', 'ç£åŠ›é“¾æ¥ä¸å­˜åœ¨')
                return False

            # æ£€æŸ¥è¯¥ç£åŠ›é“¾æ¥æ˜¯å¦å·²ç»è¢«æ ¡å‡†è¿‡
            # å¦‚æœç£åŠ›é“¾æ¥æœ‰dnå‚æ•°ï¼Œä¸”ä¸æ˜¯ä»åŸå§‹dnæå–çš„ï¼Œè¯´æ˜å·²ç»æ ¡å‡†è¿‡
            if target_magnet.get('dn'):
                from urllib.parse import parse_qs, urlparse, unquote
                try:
                    # æ£€æŸ¥æ˜¯å¦æ˜¯çœŸæ­£æ ¡å‡†è¿‡çš„æ–‡ä»¶åï¼ˆä¸æ˜¯ä»åŸå§‹dnæå–çš„ï¼‰
                    parsed = urlparse(target_magnet['magnet'])
                    params = parse_qs(parsed.query)
                    dn_values = params.get('dn', [])

                    if dn_values:
                        dn_decoded = unquote(dn_values[0])
                        # å¦‚æœdnå‚æ•°çœ‹èµ·æ¥åƒæ˜¯æ ¡å‡†åçš„å®Œæ•´æ–‡ä»¶åï¼ˆä¸æ˜¯ç®€å•çš„æ•°å­—æˆ–çŸ­æ–‡æœ¬ï¼‰
                        if len(dn_decoded) > 10 and not dn_decoded.isdigit():
                            logger.info(f"âœ… ç£åŠ›é“¾æ¥ {magnet_hash[:16]}... å·²ç»æ ¡å‡†è¿‡ï¼Œç›´æ¥æ ‡è®°ä»»åŠ¡æˆåŠŸ")
                            update_calibration_task(task_id, 'success')
                            return True
                except Exception:
                    pass

            logger.info(f"ğŸ”„ å¼€å§‹æ ¡å‡†ç£åŠ›é“¾æ¥: {magnet_hash[:16]}...")

            # æ ¡å‡†è¯¥ç£åŠ›é“¾æ¥ï¼ˆè‡ªåŠ¨æ ¡å‡†ä¼˜å…ˆä½¿ç”¨æœºå™¨äººï¼‰
            timeout = self.config.get('timeout_per_magnet', 30)
            filename = self.calibrate_magnet(magnet_hash, timeout, prefer_bot=True)

            if filename:
                logger.info(f"âœ… ç£åŠ›é“¾æ¥æ ¡å‡†æˆåŠŸ: {filename[:50]}...")

                # æ›´æ–°æ•°æ®åº“ï¼ˆåªæ›´æ–°è¿™ä¸€ä¸ªç£åŠ›é“¾æ¥ï¼‰
                calibrated_results = [{
                    'info_hash': magnet_hash,
                    'old_magnet': target_magnet['magnet'],
                    'filename': filename,
                    'success': True
                }]

                update_success = update_note_with_calibrated_dns(note_id, calibrated_results)

                if update_success:
                    logger.info(f"âœ… ç¬”è®° {note_id} æ›´æ–°æˆåŠŸï¼ˆç£åŠ›é“¾æ¥ {magnet_hash[:16]}... å·²æ ¡å‡†ï¼‰")

                    # ä½¿ç¼“å­˜å¤±æ•ˆï¼Œç¡®ä¿åˆ·æ–°é¡µé¢åèƒ½çœ‹åˆ°æ›´æ–°åçš„æ•°æ®
                    try:
                        from src.infrastructure.cache.managers import get_note_cache_manager
                        cache_manager = get_note_cache_manager()
                        user_id = note.get('user_id')
                        if user_id:
                            invalidated = cache_manager.invalidate_note(note_id, user_id)
                            logger.info(f"âœ… å·²å¤±æ•ˆç¬”è®° {note_id} çš„ç¼“å­˜ ({invalidated} ä¸ªæ¡ç›®)")
                    except Exception as e:
                        logger.warning(f"âš ï¸ ç¼“å­˜å¤±æ•ˆå¤±è´¥ (ä¸å½±å“åŠŸèƒ½): {e}")

                    update_calibration_task(task_id, 'success')
                    return True
                else:
                    logger.error(f"âŒ æ›´æ–°ç¬”è®° {note_id} å¤±è´¥")
                    update_calibration_task(task_id, 'failed', 'æ›´æ–°ç¬”è®°å¤±è´¥')
                    return False
            else:
                # æ ¡å‡†å¤±è´¥ï¼Œåˆ¤æ–­æ˜¯å¦éœ€è¦é‡è¯•
                max_retries = self.config.get('max_retries', 3)

                if retry_count < max_retries:
                    # è®¡ç®—ä¸‹æ¬¡é‡è¯•å»¶è¿Ÿï¼ˆæ¸è¿›å¼é€€é¿ï¼‰
                    retry_delays = [
                        self.config.get('retry_delay_1', 3600),   # 1å°æ—¶
                        self.config.get('retry_delay_2', 14400),  # 4å°æ—¶
                        self.config.get('retry_delay_3', 28800),  # 8å°æ—¶
                    ]
                    next_delay = retry_delays[min(retry_count, len(retry_delays) - 1)]

                    logger.info(f"â° ç£åŠ›é“¾æ¥æ ¡å‡†å¤±è´¥ï¼Œå°†åœ¨ {next_delay // 3600} å°æ—¶åé‡è¯•")
                    update_calibration_task(task_id, 'retrying', 'æ ¡å‡†å¤±è´¥ï¼Œç­‰å¾…é‡è¯•', next_delay)
                    return False
                else:
                    # è¶…è¿‡æœ€å¤§é‡è¯•æ¬¡æ•°ï¼Œæ ‡è®°å¤±è´¥
                    logger.warning(f"âŒ ç£åŠ›é“¾æ¥æ ¡å‡†å¤±è´¥ï¼ˆå·²é‡è¯•{max_retries}æ¬¡ï¼‰: hash={magnet_hash[:16]}...")
                    update_calibration_task(task_id, 'failed', f'æ ¡å‡†å¤±è´¥ï¼ˆå·²é‡è¯•{max_retries}æ¬¡ï¼‰')
                    return False

        except Exception as e:
            logger.error(f"å¤„ç†æ ¡å‡†ä»»åŠ¡æ—¶å‡ºé”™: {e}", exc_info=True)
            update_calibration_task(task_id, 'failed', str(e))
            return False

    def process_pending_tasks(self, max_concurrent: int = 5):
        """æ‰¹é‡å¤„ç†å¾…æ‰§è¡Œçš„æ ¡å‡†ä»»åŠ¡

        Args:
            max_concurrent: æœ€å¤§å¹¶å‘æ•°
        """
        if not self.is_enabled():
            logger.debug("è‡ªåŠ¨æ ¡å‡†æœªå¯ç”¨")
            return

        try:
            tasks = get_pending_calibration_tasks(limit=max_concurrent)

            if not tasks:
                logger.debug("æ²¡æœ‰å¾…å¤„ç†çš„æ ¡å‡†ä»»åŠ¡")
                return

            logger.info(f"ğŸ“‹ å‘ç° {len(tasks)} ä¸ªå¾…å¤„ç†çš„æ ¡å‡†ä»»åŠ¡")

            success_count = 0
            for task in tasks:
                try:
                    if self.process_calibration_task(task):
                        success_count += 1
                except Exception as e:
                    logger.error(f"å¤„ç†ä»»åŠ¡ {task['id']} æ—¶å‡ºé”™: {e}", exc_info=True)

            logger.info(f"âœ… æ‰¹é‡å¤„ç†å®Œæˆ: æˆåŠŸ {success_count}/{len(tasks)}")

        except Exception as e:
            logger.error(f"æ‰¹é‡å¤„ç†æ ¡å‡†ä»»åŠ¡å¤±è´¥: {e}", exc_info=True)

    def get_stats(self) -> Dict:
        """è·å–æ ¡å‡†ä»»åŠ¡ç»Ÿè®¡ä¿¡æ¯"""
        return get_calibration_stats()


# å…¨å±€å®ä¾‹
_calibration_manager = None


def get_calibration_manager() -> CalibrationManager:
    """è·å–å…¨å±€æ ¡å‡†ç®¡ç†å™¨å®ä¾‹"""
    global _calibration_manager
    if _calibration_manager is None:
        _calibration_manager = CalibrationManager()
    return _calibration_manager
